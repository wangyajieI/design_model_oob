# design_model_oob
引用自 https://www.cnblogs.com/temptation/archive/2008/03/10/1098351.html

**面向对象的可复用设计（OOD）七大原则**

* **开放封闭原则**
  * 对扩展开放，而对修改封闭，开-闭原则是可复用设计的基石，其他原则都是实现开-闭原则的手段和工具
    * 已有的软件模块，特别是重要的抽象层模块不能再修改。
    * 新的软件需求通过扩展已有的软件系统实现。
    * 整体上满足可复用性（抽象层）+ 可维护性（实现层）
  * 如何实现开-闭原则？
    * 定义一个一劳永逸的抽象设计层，允许尽可能多的行为在实现层实现
    * 找到设计中，什么可能会发生变化，将这些东西封装成抽象层，而不是什么会导致设计改变才封装
    * 继承是封装变化的方法，可以将每种可变性都封装成为一个抽象类，而将其的不同表现作为具体子类加以实现（继承）
* **单一职责原则**
  * 一个类只负责一项职责
* **里氏替换原则（LSP）**
  *  所有基类出现的地方，都可以使用子类进行替换，子类可以扩展父类的功能，但不能改变父类原有的功能
  * 里氏替换原则是对实现抽象化的具体步骤的规范。违反了里氏替换原则，则一定违反了开-闭原则，反之未必
* **接口隔离原则**
  * 接口中的方法要足够少，接口功能要尽量细分。
  * 客户需要什么接口，就提供什么接口，不要有无关的接口；类之间的依赖关系应监立在最小的接口上
* **依赖倒置原则（DIP）**
  * 针对接口编程，而不要针对实现编程
  * 应当使用接口和抽象类进行变量类型声明、参数类型声明、方法返回值类型声明以及数据类型转换等。也就是说，一个具体实现类应该只实现接口和抽象类中声明过的方法，而不要给出多余的方法
  * 特例：对象的创建过程是违背开-闭原则以及依赖倒转原则的，但通过工厂模式，能很好的解决对象创建过程中的依赖倒转问题
  * 开-闭原则与依赖倒转原则是目标和手段的关系，，依赖倒转原则是为了达到最好的开-闭原则，是对“抽象化”最好的规范
  * 里氏替换原则是依赖倒转原则的基础，依赖倒转原则是里氏替换原则的重要补充。
  * 耦合（依赖）关系补充
    * 零耦合（Nil Coupling）：两个类没有耦合关系
    * 具体耦合关系（Concrete Coupling）：两个具体的（可实例化的）类之间，经由一个类对另一个具体类的直接引用造成。
    * 抽象耦合关系（Abstract Coupling）： 一个具体类和一个抽象类（或接口）之间，使两个必须发生关系的类之间具有最大的灵活性
    * 如何把握耦合
      * 尽量避免继承，因为会失去灵活性，使用具体类会给底层修改带来麻烦
      * 耦合并非完全是坏的，因为系统不可能总是松耦合的，那样肯定什么也做不了。系统必须高内聚的实现一部分功能，这就需要耦合。
    * 如何决定耦合的程度
      * 根据需求的稳定性决定，对于稳定性高的，不容易发生变化的需求，完全可以把各类设计成紧耦合的，因为这样可以提高效率，并且可能有更好的方法来实现（提高效率、简化代码）；如果需求极有可能变化，我们就需要充分考虑类之间的耦合问题，这样，就需要各种办法来降低耦合程度，但是归纳而言，不外乎增加抽象层次来隔离不同的类，这个抽象层次可以是抽象类、具体类、接口或者一组类，也就是，针对接口编程，而不是针对实现编程。
      * 如何判断系统的稳定性
        * 类的不稳定因素 = 依赖的类个数/被依赖的类个数
        * 依赖的类个数 = 在编译此类的时候被编译的其他类的个数总和
    * 如何把大系统拆分为小系统
      * 核心：将需对类集合成一个更高层次的单位，形成一个高内聚、低耦合的类的集合
      * <u>耦合的目标是维护依赖的单向性，有时我们也会遇到坏的耦合，在这种情况下，应当小心记录下原因，以变日后维护该代码的用户了解使用耦合的真正原因</u>
  * 如何做到依赖倒转
    * 关键：以抽象方式耦合，即耦合最少的东西
    * 注：抽象耦合关系总是设计具体类从抽象继承，并且需要保证在任何引用到基类的地方都可以改换成子类，因此，<u>里氏替换原则是依赖倒转原则的基础</u>
    * 注：抽象层次的耦合虽然有灵活性，但是却增加了复杂度，如果具体类发生变化的可能性很小，那么此时不一定要抽象耦合，具体耦合反而会更好一点
    * 层次化：所有结构良好的，面向对象的构架都有清晰的层次定义，每个层次通过一个定义良好的、受控的接口向外提供一组内聚服务
    * 依赖于抽象，即程序中所有依赖关系都应该终止于抽象类或接口，尽量做到：
      * 任何变量都不应该持有一个指向具体类的指针或引用
      * 任何类都不应该从具体类中派生
      * 任何方法都不应该覆写它的任何基类中已实现的方法
  * 依赖倒转的优缺点：
    * 强大，但最不容易实现，因为依赖倒转的缘故，对象的创建很可能要使用对象工厂，以避免对具体类的直接引用。此原则的使用还会导致产生大量的类，对不熟悉面向对象的工程师而言，维护这样的系统需要较好的理解面向对象设计
    * 依赖倒转原则假定所有的具体类都是会变化的，这也不总是正确，有一些类可能是相当稳定的，不会变化，使用这个具体类实例的应用应该可以完全依赖于这个具体的类，而不必为此创建一个抽象模型
* 合成/聚合复用原则（CARP）
  * 定义：在一个新对象里面使用一些已有的对象，使之成为新对象的一部分；新对象通过向这些对象的委派达到复用这些对象的目的
  * 应首先使用合成/聚合，合成/聚合使得系统灵活。其次才考虑继承，达到复用的目的。而使用继承时，要严格遵循里氏代换原则。有效的使用继承会有助于对问题的理解，降低复杂度，而滥用继承会增加系统构建、维护时的难度和系统的复杂度。
  * 如果两个类是“has-a"的关系，应该使用合成、聚合；如果是”is-a“关系可使用继承。”is-a“是严格的分类学意义上的定义，意思是一个类是另一个类的”一种“。而”has-a"则不同，它表示某一个角色具有某项责任。
  * 什么是合成？什么是聚合？
    * 合成（composition）和聚合（Aggregation）都是关联（Association）的特殊种类
    * 聚合代表整体和部分的关系，表示”拥有“，如小米8手机，对小米8摄像头、小米8屏幕是聚合关系，离开了整体的小米8手机，摄像头、屏幕无法单独提供服务，也就没有了意义。在设计中，聚合不应该频繁出现，这样会增大耦合度。
    * 合成则是一种更强的“拥有”， 部分和整体的生命周期一样，合成的新对象完全支配其组成部分，包括它们的创建和湮灭等。一个合成关系的成分对象是不能与另一个合成关系共享的。
    * 换句话说，合成是值的聚合（Aggregation by value），而一般说的聚合则是引用的聚合（Aggregation by reference）
    * 合成/聚合原则就是，要避免在系统设计中出现，一个类的继承层次超过三层，否则应该考虑重构代码，或者重新设计结构。当然最好是使用合成/集合原则。
  * 通过合成/聚合的优缺点
    * 优点：
      * 新对象存取成分对象的唯一方法是通过成分对象的接口
      * 这种复用是黑箱复用，因为成分对象的内部细节是新对象所看不见的
      * 这种复用支持包装，且所需要的依赖较少
      * 每一个新的类可以将焦点集中在一个任务上
      * 复用可以在运行时间内动态进行，新对象可以动态的引用与成分对象类型相同的对象
      * 可以作为复用手段应用到几乎任何环境中去
    * 缺点：
      * 系统中会有较多的对象需要管理
  * 对比：通过继承来进行复用的优缺点
    * 优点：
      * 新的实现较为容易，因为超类的大部分功能可以通过继承关系自动进入子类
      * 修改和扩展继承而来的实现较为容易
    * 缺点
      * 继承复用破坏包装，因为继承将超类的实现暴露给了子类。由于超类的内部细节常常对于子类是透明的，所以这种复用是透明的复用，又称为“白箱”复用
      * 如果超类发生改变，那么子类实现也不得不发生改变
      * 从超类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性
      * 继承只能在有限的环境中使用
* 迪米特法则
